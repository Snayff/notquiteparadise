

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>scripts.engine.ui.elements.data_editor &mdash; NotQuiteParadise  documentation</title>
  

  
  <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
        <script src="../../../../../_static/jquery.js"></script>
        <script src="../../../../../_static/underscore.js"></script>
        <script src="../../../../../_static/doctools.js"></script>
        <script src="../../../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../../index.html" class="icon icon-home" alt="Documentation Home"> NotQuiteParadise
          

          
          </a>

          
            
            
              <div class="version">
                0.134.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Core API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/core.constants.html">Constants</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/core.definitions.html">Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/core.extend_json.html">Extend Json</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/core.store.html">Store</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/core.queries.html">Queries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/core.systems.html">Systems</a></li>
</ul>
<p class="caption"><span class="caption-text">General API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/action.html">Action</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/chronicle.html">Chronicle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/component.html">Component</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/debug.html">Debug</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/dungen.html">Dungen</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/effect.html">Effect</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/key.html">Key</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/library.html">Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/state.html">State</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/utility.html">Utility</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/world.html">World</a></li>
</ul>
<p class="caption"><span class="caption-text">World Objects API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/world_objects.html">World Objects</a></li>
</ul>
<p class="caption"><span class="caption-text">UI API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/ui.elements.html">UI Elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../nqp/ui.widgets.html">UI Widgets</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">NotQuiteParadise</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../../index.html">Module code</a> &raquo;</li>
        
      <li>scripts.engine.ui.elements.data_editor</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for scripts.engine.ui.elements.data_editor</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">dataclasses</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span>

<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">import</span> <span class="nn">pygame_gui</span>
<span class="kn">from</span> <span class="nn">pygame_gui.core</span> <span class="kn">import</span> <span class="n">UIContainer</span>
<span class="kn">from</span> <span class="nn">pygame_gui.elements</span> <span class="kn">import</span> <span class="n">UIButton</span><span class="p">,</span> <span class="n">UIDropDownMenu</span><span class="p">,</span> <span class="n">UILabel</span><span class="p">,</span> <span class="n">UITextEntryLine</span><span class="p">,</span> <span class="n">UIWindow</span>

<span class="kn">from</span> <span class="nn">scripts.engine</span> <span class="kn">import</span> <span class="n">utility</span>
<span class="kn">from</span> <span class="nn">scripts.engine.core.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AfflictionCategory</span><span class="p">,</span>
    <span class="n">DamageType</span><span class="p">,</span>
    <span class="n">Direction</span><span class="p">,</span>
    <span class="n">EffectType</span><span class="p">,</span>
    <span class="n">PrimaryStat</span><span class="p">,</span>
    <span class="n">ProjectileExpiry</span><span class="p">,</span>
    <span class="n">Resource</span><span class="p">,</span>
    <span class="n">SecondaryStat</span><span class="p">,</span>
    <span class="n">Shape</span><span class="p">,</span>
    <span class="n">TargetTag</span><span class="p">,</span>
    <span class="n">TerrainCollision</span><span class="p">,</span>
    <span class="n">TravelMethod</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">scripts.engine.core.definitions</span> <span class="kn">import</span> <span class="n">EffectData</span><span class="p">,</span> <span class="n">SkillData</span><span class="p">,</span> <span class="n">TraitData</span>
<span class="kn">from</span> <span class="nn">scripts.engine.core.extend_json</span> <span class="kn">import</span> <span class="n">ExtendedJsonEncoder</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

    <span class="kn">from</span> <span class="nn">pygame_gui</span> <span class="kn">import</span> <span class="n">UIManager</span>


<div class="viewcode-block" id="DataEditor"><a class="viewcode-back" href="../../../../../scripts.engine.ui.elements.html#scripts.engine.ui.elements.data_editor.DataEditor">[docs]</a><span class="k">class</span> <span class="nc">DataEditor</span><span class="p">(</span><span class="n">UIWindow</span><span class="p">):</span>
    <span class="k">pass</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Dev tool to allow creating and editing data.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#     def __init__(self, rect, manager):</span>
    <span class="c1">#         super().__init__(rect, manager, &quot;data_editor&quot;)</span>
    <span class="c1">#</span>
    <span class="c1">#         # data holders</span>
    <span class="c1">#         self.all_data: Dict[str, Dict[str, dataclass()]] = {}</span>
    <span class="c1">#         self.current_data_category: str = None</span>
    <span class="c1">#         self.current_data_instance: str = None</span>
    <span class="c1">#         self.current_primary_field: str = None</span>
    <span class="c1">#         self.current_secondary_field: str = None</span>
    <span class="c1">#         self.key_being_edited: str = None</span>
    <span class="c1">#         self.field_options: Dict[str, Tuple[List[str], Optional[dataclass]]] = {}</span>
    <span class="c1">#</span>
    <span class="c1">#         # data selectors</span>
    <span class="c1">#         self.category_selector: UIDropDownMenu = None</span>
    <span class="c1">#         self.instance_selector: UIDropDownMenu = None</span>
    <span class="c1">#</span>
    <span class="c1">#         # dicts of data fields</span>
    <span class="c1">#         self.primary_data_fields: Dict[str, DataField] = {}</span>
    <span class="c1">#         self.secondary_data_fields: Dict[str, DataField] = {}</span>
    <span class="c1">#</span>
    <span class="c1">#         # size info</span>
    <span class="c1">#         self.start_x = 2</span>
    <span class="c1">#         self.start_y = 2</span>
    <span class="c1">#         self.width = self.rect.width</span>
    <span class="c1">#         self.height = self.rect.height</span>
    <span class="c1">#         self.row_height = 25</span>
    <span class="c1">#         self.max_rows = self.height // self.row_height</span>
    <span class="c1">#         self.selectors_end_y = self.start_y + (self.row_height * 2)  # 2 is number of selectors</span>
    <span class="c1">#</span>
    <span class="c1">#         self.primary_x = self.start_x</span>
    <span class="c1">#         self.primary_y = self.selectors_end_y</span>
    <span class="c1">#         self.primary_width = self.width // 2</span>
    <span class="c1">#</span>
    <span class="c1">#         self.secondary_x = self.primary_x + self.primary_width</span>
    <span class="c1">#         self.secondary_y = self.selectors_end_y</span>
    <span class="c1">#         self.secondary_width = self.width - self.primary_width</span>
    <span class="c1">#</span>
    <span class="c1">#         self.label_width_mod = 0.3  # decimal % of row width that label takes up</span>
    <span class="c1">#</span>
    <span class="c1">#         self.max_y = self.height</span>
    <span class="c1">#</span>
    <span class="c1">#         # get the data &amp; field options</span>
    <span class="c1">#         self._load_library_data()</span>
    <span class="c1">#         self._load_field_options()</span>
    <span class="c1">#</span>
    <span class="c1">#         # display the initial selector</span>
    <span class="c1">#         self.category_selector = self._create_data_category_selector()</span>
    <span class="c1">#</span>
<div class="viewcode-block" id="DataEditor.update"><a class="viewcode-back" href="../../../../../scripts.engine.ui.elements.html#scripts.engine.ui.elements.data_editor.DataEditor.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">pass</span></div>

    <span class="c1">#         &quot;&quot;&quot;</span>
    <span class="c1">#         Update based on current state and data. Run every frame.</span>
    <span class="c1">#         &quot;&quot;&quot;</span>
    <span class="c1">#         super().update(time_delta)</span>
    <span class="c1">#</span>
<div class="viewcode-block" id="DataEditor.handle_events"><a class="viewcode-back" href="../../../../../scripts.engine.ui.elements.html#scripts.engine.ui.elements.data_editor.DataEditor.handle_events">[docs]</a>    <span class="k">def</span> <span class="nf">handle_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">pass</span></div></div>


<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Handle events created by this UI widget</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         ui_object_id = event.ui_object_id</span>
<span class="c1">#         new_value = None</span>
<span class="c1">#         data_field = None</span>
<span class="c1">#</span>
<span class="c1">#         # new selection in instance_selector</span>
<span class="c1">#         if ui_object_id == &quot;category_selector&quot;:</span>
<span class="c1">#             if event.user_type == pygame_gui.UI_DROP_DOWN_MENU_CHANGED:</span>
<span class="c1">#                 if self.category_selector.selected_option != self.current_data_category:</span>
<span class="c1">#                     self._select_new_category(self.category_selector.selected_option)</span>
<span class="c1">#</span>
<span class="c1">#         # new selection in instance_selector</span>
<span class="c1">#         if ui_object_id == &quot;instance_selector&quot;:</span>
<span class="c1">#             if event.user_type == pygame_gui.UI_DROP_DOWN_MENU_CHANGED:</span>
<span class="c1">#                 if self.instance_selector.selected_option != self.current_data_instance:</span>
<span class="c1">#                     self._select_new_instance(self.instance_selector.selected_option)</span>
<span class="c1">#</span>
<span class="c1">#         # new selection in a different, non-selector dropdown</span>
<span class="c1">#         if ui_object_id != &quot;instance_selector&quot; and ui_object_id != &quot;category_selector&quot;:</span>
<span class="c1">#             if event.user_type == pygame_gui.UI_DROP_DOWN_MENU_CHANGED:</span>
<span class="c1">#                 data_field, new_value = self._process_dropdown_change(ui_object_id)</span>
<span class="c1">#</span>
<span class="c1">#         # handle text field finished typing (triggers on enter press)</span>
<span class="c1">#         if event.user_type == pygame_gui.UI_TEXT_ENTRY_FINISHED:</span>
<span class="c1">#             data_field, new_value = self._process_textbox_change(ui_object_id)</span>
<span class="c1">#</span>
<span class="c1">#         # handle triggers for secondary details</span>
<span class="c1">#         prefix = &quot;edit#&quot;</span>
<span class="c1">#         if ui_object_id[:len(prefix)] == prefix:</span>
<span class="c1">#             data_field, new_value = self._process_edit_action(ui_object_id)</span>
<span class="c1">#</span>
<span class="c1">#         # handle multiple choice to toggle the value</span>
<span class="c1">#         prefix = &quot;multi#&quot;</span>
<span class="c1">#         if ui_object_id[:len(prefix)] == prefix:</span>
<span class="c1">#             data_field, new_value = self._process_multi_action(ui_object_id)</span>
<span class="c1">#</span>
<span class="c1">#         # update selected fields</span>
<span class="c1">#         if data_field:</span>
<span class="c1">#             if data_field.primary_or_secondary == &quot;primary&quot;:</span>
<span class="c1">#                 self.current_primary_field = data_field.key</span>
<span class="c1">#             else:</span>
<span class="c1">#                 self.current_secondary_field = data_field.key</span>
<span class="c1">#</span>
<span class="c1">#             if new_value is not None:</span>
<span class="c1">#                 # process the update and reload</span>
<span class="c1">#                 primary_or_secondary = data_field.primary_or_secondary</span>
<span class="c1">#</span>
<span class="c1">#                 self._save_updated_field(primary_or_secondary, data_field, new_value)</span>
<span class="c1">#</span>
<span class="c1">#                 # clear existing</span>
<span class="c1">#                 self._kill_details_fields(primary_or_secondary)</span>
<span class="c1">#</span>
<span class="c1">#                 # reload to reflect new changes</span>
<span class="c1">#                 self._load_details(primary_or_secondary, self.current_data_instance)</span>
<span class="c1">#</span>
<span class="c1">#     ################# INTERACT ################</span>
<span class="c1">#</span>
<span class="c1">#     def _select_new_category(self, category: str):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Select new category, clear existing data fields and create_entity new instance options from category.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         self.current_data_category = category</span>
<span class="c1">#</span>
<span class="c1">#         # clear existing details fields</span>
<span class="c1">#         self._kill_details_fields(&quot;primary&quot;)</span>
<span class="c1">#         self._kill_details_fields(&quot;secondary&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         # clear existing instance selector</span>
<span class="c1">#         if self.instance_selector:</span>
<span class="c1">#             self.instance_selector.kill()</span>
<span class="c1">#             self.instance_selector = None</span>
<span class="c1">#</span>
<span class="c1">#         # create new instance selector</span>
<span class="c1">#         options: List[str] = []</span>
<span class="c1">#         options.extend(key for key in self.all_data[self.current_data_category].keys())</span>
<span class="c1">#         options.sort()</span>
<span class="c1">#         self.instance_selector = self._create_data_instance_selector(options)</span>
<span class="c1">#</span>
<span class="c1">#     def _select_new_instance(self, instance: str):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Select new data instance and clear current data fields before loading primary data details</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # clear existing details fields</span>
<span class="c1">#         self._kill_details_fields(&quot;primary&quot;)</span>
<span class="c1">#         self._kill_details_fields(&quot;secondary&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         # create new</span>
<span class="c1">#         self.current_data_instance = instance</span>
<span class="c1">#         self._load_details(&quot;primary&quot;, self.current_data_instance)</span>
<span class="c1">#</span>
<span class="c1">#     def _process_dropdown_change(self, object_id: str) -&gt; Tuple[Optional[DataField], Any]:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Check if new option selected in dropdown and if so return data_field and new value</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         key = object_id</span>
<span class="c1">#</span>
<span class="c1">#         try:</span>
<span class="c1">#             data_field = self.secondary_data_fields[key]</span>
<span class="c1">#         except KeyError:</span>
<span class="c1">#             data_field = self.primary_data_fields[key]</span>
<span class="c1">#</span>
<span class="c1">#         new_value = data_field.input_element.selected_option</span>
<span class="c1">#</span>
<span class="c1">#         # check the value has changed</span>
<span class="c1">#         if new_value != data_field.value:</span>
<span class="c1">#             return data_field, new_value</span>
<span class="c1">#</span>
<span class="c1">#         return None, None</span>
<span class="c1">#</span>
<span class="c1">#     def _process_textbox_change(self, object_id: str) -&gt; Tuple[Optional[DataField], Any]:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Check if text has changed and return data field and new value&quot;&quot;&quot;</span>
<span class="c1">#         key = object_id</span>
<span class="c1">#         try:</span>
<span class="c1">#             data_field = self.secondary_data_fields[key]</span>
<span class="c1">#         except KeyError:</span>
<span class="c1">#             data_field = self.primary_data_fields[key]</span>
<span class="c1">#</span>
<span class="c1">#         new_value = data_field.input_element.text</span>
<span class="c1">#</span>
<span class="c1">#         # check the value has changed</span>
<span class="c1">#         if new_value != data_field.value:</span>
<span class="c1">#             return data_field, new_value</span>
<span class="c1">#</span>
<span class="c1">#         return None, None</span>
<span class="c1">#</span>
<span class="c1">#     def _process_edit_action(self, object_id: str) -&gt; Tuple[Optional[DataField], None]:</span>
<span class="c1">#         # get the key</span>
<span class="c1">#         prefix, key, _object_id = object_id.split(&quot;#&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         # clear existing details fields N.B. edit can only be in primary</span>
<span class="c1">#         self._kill_details_fields(&quot;secondary&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         #  load secondary details</span>
<span class="c1">#         self._load_details(&quot;secondary&quot;, self.current_data_instance, (key, _object_id))</span>
<span class="c1">#</span>
<span class="c1">#         self.key_being_edited = _object_id</span>
<span class="c1">#</span>
<span class="c1">#         data_field = self.primary_data_fields[key]</span>
<span class="c1">#         return data_field, None</span>
<span class="c1">#</span>
<span class="c1">#     def _process_multi_action(self, object_id: str) -&gt; Tuple[Optional[DataField], Any]:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Toggle selected option in the relevant field&quot;&quot;&quot;</span>
<span class="c1">#         # get the key</span>
<span class="c1">#         prefix, key, _object_id = object_id.split(&quot;#&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         try:</span>
<span class="c1">#             data_field = self.secondary_data_fields[key]</span>
<span class="c1">#         except KeyError:</span>
<span class="c1">#             data_field = self.primary_data_fields[key]</span>
<span class="c1">#</span>
<span class="c1">#         # get current value</span>
<span class="c1">#         current_value: List = data_field.value</span>
<span class="c1">#         id_as_value = _object_id</span>
<span class="c1">#</span>
<span class="c1">#         if id_as_value in current_value:</span>
<span class="c1">#             current_value.remove(id_as_value)</span>
<span class="c1">#         else:</span>
<span class="c1">#             current_value.append(id_as_value)</span>
<span class="c1">#</span>
<span class="c1">#         new_value = current_value</span>
<span class="c1">#</span>
<span class="c1">#         return data_field, new_value</span>
<span class="c1">#</span>
<span class="c1">#     ############## CREATE ################</span>
<span class="c1">#</span>
<span class="c1">#     def _create_data_category_selector(self) -&gt; UIDropDownMenu:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Create the category selector drop down menu</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # get options and sort alphabetically</span>
<span class="c1">#         options = [keys for keys in self.all_data.keys()]</span>
<span class="c1">#         options.sort()</span>
<span class="c1">#</span>
<span class="c1">#         rect = pygame.Rect((self.start_x, self.start_y), (self.width, self.row_height))</span>
<span class="c1">#</span>
<span class="c1">#         return UIDropDownMenu(options, &quot;None&quot;, rect, self.ui_manager, container=self.get_container(),</span>
<span class="c1">#                               parent_element=self, object_id=&quot;category_selector&quot;)</span>
<span class="c1">#</span>
<span class="c1">#     def _create_data_instance_selector(self, options: List[str]) -&gt; UIDropDownMenu:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Create the instance selector drop down menu</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         rect = pygame.Rect((self.start_x, self.start_y + self.row_height), (self.width, self.row_height))</span>
<span class="c1">#</span>
<span class="c1">#         _options = options</span>
<span class="c1">#         _options.insert(0, &quot;new&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         return UIDropDownMenu(_options, &quot;None&quot;, rect, self.ui_manager, container=self.get_container(),</span>
<span class="c1">#                               parent_element=self, object_id=&quot;instance_selector&quot;)</span>
<span class="c1">#</span>
<span class="c1">#     def _create_one_from_options_field(self, key: str, value: Any, options: List[str], x: int, y: int, width: int,</span>
<span class="c1">#             height: int, container: UIContainer, ui_manager: UIManager) -&gt; DataField:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Create a data field containing label, current value and a dropdown of possible options.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # split out the elements of the key</span>
<span class="c1">#         primary_or_secondary, _key = key.split(&quot;#&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         labels = []</span>
<span class="c1">#         _options = [option.lower() for option in options]</span>
<span class="c1">#</span>
<span class="c1">#         # get value name</span>
<span class="c1">#         if value:</span>
<span class="c1">#             value_name = value</span>
<span class="c1">#         else:</span>
<span class="c1">#             value_name = &quot;None&quot;</span>
<span class="c1">#</span>
<span class="c1">#         # insert none option</span>
<span class="c1">#         _options.insert(0, &quot;None&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         _options.sort()</span>
<span class="c1">#</span>
<span class="c1">#         # create the key label</span>
<span class="c1">#         key_width = int(width * self.label_width_mod)</span>
<span class="c1">#         key_rect = pygame.Rect((x, y), (key_width, height))</span>
<span class="c1">#         key_label = UILabel(key_rect, _key, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#         labels.append(key_label)</span>
<span class="c1">#</span>
<span class="c1">#         # create the current values label</span>
<span class="c1">#         value_width = width - key_width</span>
<span class="c1">#         value_x = x + key_width</span>
<span class="c1">#         value_rect = pygame.Rect((value_x, y), (value_width, height))</span>
<span class="c1">#         value_label = UILabel(value_rect, value_name, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#         labels.append(value_label)</span>
<span class="c1">#</span>
<span class="c1">#         # create the option&#39;s dropdown, incremented by height</span>
<span class="c1">#         input_rect = pygame.Rect((x, y + height), (width, height))</span>
<span class="c1">#         input = UIDropDownMenu(_options, value_name, input_rect, ui_manager, container=container,</span>
<span class="c1">#                                parent_element=self, object_id=_key)</span>
<span class="c1">#</span>
<span class="c1">#         # create the data field</span>
<span class="c1">#         data_field = DataField(primary_or_secondary, _key, value, value_name, str, labels, height * 2,</span>
<span class="c1">#                                input_element=input, options=_options)</span>
<span class="c1">#</span>
<span class="c1">#         return data_field</span>
<span class="c1">#</span>
<span class="c1">#     def _create_edit_detail_field(self, key: str, value: Any, options: List[str], x: int, y: int, width: int,</span>
<span class="c1">#             height: int, container: UIContainer, ui_manager: UIManager) -&gt; DataField:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Create a data field containing label, current values and a row of buttons for possible options. Buttons are</span>
<span class="c1">#         prefixed with edit#</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # split out the elements of the key</span>
<span class="c1">#         primary_or_secondary, _key = key.split(&quot;#&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         labels = []</span>
<span class="c1">#         prefixed_options: List[str] = []</span>
<span class="c1">#         values_list: List[str] = []</span>
<span class="c1">#</span>
<span class="c1">#         # Turn value into a list of strings</span>
<span class="c1">#         prefixed_options.extend(f&quot;edit#{_key}#{name.lower()}&quot; for name in options)</span>
<span class="c1">#         if value:</span>
<span class="c1">#             values_list.extend(name for name in value.keys())</span>
<span class="c1">#</span>
<span class="c1">#         # sort lists alphabetically</span>
<span class="c1">#         prefixed_options.sort()</span>
<span class="c1">#         values_list.sort()</span>
<span class="c1">#</span>
<span class="c1">#         # create the key label</span>
<span class="c1">#         key_width = int(width * self.label_width_mod)</span>
<span class="c1">#         key_rect = pygame.Rect((x, y), (key_width, height))</span>
<span class="c1">#         key_label = UILabel(key_rect, _key, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#         labels.append(key_label)</span>
<span class="c1">#</span>
<span class="c1">#         # convert the list to a string</span>
<span class="c1">#         values_str = &quot;, &quot;.join(values_list)</span>
<span class="c1">#         values_str += &quot;, &quot;  # add comma to the end to help delimit when adding other values</span>
<span class="c1">#</span>
<span class="c1">#         # create the current values label</span>
<span class="c1">#         value_width = width - key_width</span>
<span class="c1">#         value_x = x + key_width</span>
<span class="c1">#         value_rect = pygame.Rect((value_x, y), (value_width, height))</span>
<span class="c1">#         value_label = UILabel(value_rect, values_str, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#         labels.append(value_label)</span>
<span class="c1">#</span>
<span class="c1">#         # determine how wide to make buttons</span>
<span class="c1">#         button_width = width // len(prefixed_options)</span>
<span class="c1">#</span>
<span class="c1">#         # create the option&#39;s buttons, incremented by height</span>
<span class="c1">#         buttons = self._create_row_of_buttons(prefixed_options, x, y + height, button_width, height)</span>
<span class="c1">#</span>
<span class="c1">#         # create the data field</span>
<span class="c1">#         data_field = DataField(primary_or_secondary, _key, value, values_str, Dict, labels, height * 2,</span>
<span class="c1">#                                buttons=buttons, options=prefixed_options)</span>
<span class="c1">#</span>
<span class="c1">#         return data_field</span>
<span class="c1">#</span>
<span class="c1">#     def _create_multiple_from_options_field(self, key: str, value: Any, options: List[str], x: int, y: int,</span>
<span class="c1">#             width: int, height: int, container: UIContainer, ui_manager: UIManager) -&gt; DataField:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Create a data field containing label, current values and a row of buttons for possible options. Button&#39;s</span>
<span class="c1">#         object_ids are prefixed with multi#</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # split out the elements of the key</span>
<span class="c1">#         primary_or_secondary, _key = key.split(&quot;#&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         labels = []</span>
<span class="c1">#         prefixed_options: List[str] = []</span>
<span class="c1">#         values_list: List[str] = []</span>
<span class="c1">#</span>
<span class="c1">#         # add prefix</span>
<span class="c1">#         prefixed_options.extend(f&quot;multi#{_key}#{name.lower()}&quot; for name in options)</span>
<span class="c1">#         values_list.extend(name for name in value)</span>
<span class="c1">#</span>
<span class="c1">#         # replace spaces with underscores as object_id doesnt like spaces</span>
<span class="c1">#         # values_list = [new_value.replace(&quot; &quot;, &quot;_&quot;) for new_value in values_list]</span>
<span class="c1">#         # prefixed_options = [new_value.replace(&quot; &quot;, &quot;_&quot;) for new_value in options]</span>
<span class="c1">#</span>
<span class="c1">#         # sort lists alphabetically</span>
<span class="c1">#         prefixed_options.sort()</span>
<span class="c1">#         values_list.sort()</span>
<span class="c1">#</span>
<span class="c1">#         # create the key label</span>
<span class="c1">#         key_width = int(width * self.label_width_mod)</span>
<span class="c1">#         key_rect = pygame.Rect((x, y), (key_width, height))</span>
<span class="c1">#         key_label = UILabel(key_rect, _key, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#         labels.append(key_label)</span>
<span class="c1">#</span>
<span class="c1">#         # convert the list to a string</span>
<span class="c1">#         values_str = &quot;, &quot;.join(values_list)</span>
<span class="c1">#</span>
<span class="c1">#         # add comma to the end to help delimit when adding other values, unless there are no values!</span>
<span class="c1">#         if values_str != &quot;&quot;:</span>
<span class="c1">#             values_str += &quot;, &quot;</span>
<span class="c1">#</span>
<span class="c1">#         # create the current values label</span>
<span class="c1">#         value_width = width - key_width</span>
<span class="c1">#         value_x = x + key_width</span>
<span class="c1">#         value_rect = pygame.Rect((value_x, y), (value_width, height))</span>
<span class="c1">#         value_label = UILabel(value_rect, values_str, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#         labels.append(value_label)</span>
<span class="c1">#</span>
<span class="c1">#         # determine how wide to make buttons</span>
<span class="c1">#         button_width = width // len(prefixed_options)</span>
<span class="c1">#</span>
<span class="c1">#         # create the option&#39;s buttons, incremented by height</span>
<span class="c1">#         buttons = self._create_row_of_buttons(prefixed_options, x, y + height, button_width, height)</span>
<span class="c1">#</span>
<span class="c1">#         # create the data field</span>
<span class="c1">#         data_field = DataField(primary_or_secondary, _key, value, values_str, List, labels, height * 2,</span>
<span class="c1">#                                buttons=buttons, options=prefixed_options)</span>
<span class="c1">#</span>
<span class="c1">#         return data_field</span>
<span class="c1">#</span>
<span class="c1">#     def _create_text_entry_field(self, key, value, x, y, width, height, container, ui_manager) -&gt; DataField:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Create a data field containing a text input widget.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # split out the elements of the key</span>
<span class="c1">#         primary_or_secondary,  _key = key.split(&quot;#&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         # create the label</span>
<span class="c1">#         label_width = int(width * self.label_width_mod)</span>
<span class="c1">#         label_rect = pygame.Rect((x, y), (label_width, height))</span>
<span class="c1">#         label = UILabel(label_rect, _key, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#</span>
<span class="c1">#         # create the input</span>
<span class="c1">#         input_width = width - label_width</span>
<span class="c1">#         input_x = x + label_width</span>
<span class="c1">#         input_rect = pygame.Rect((input_x, y), (input_width, height))</span>
<span class="c1">#         input = UITextEntryLine(input_rect, ui_manager, container=container, parent_element=self, object_id=_key)</span>
<span class="c1">#         input.set_text(f&quot;{value}&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         # create the data field</span>
<span class="c1">#         data_field = DataField(primary_or_secondary, _key, value, str(value), str, [label], height,</span>
<span class="c1">#                                input_element=input)</span>
<span class="c1">#</span>
<span class="c1">#         return data_field</span>
<span class="c1">#</span>
<span class="c1">#     def _create_row_of_buttons(self, button_names: List[str], x: int, y: int, width: int, height: int) -&gt; Dict[</span>
<span class="c1">#         str, UIButton]:</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Create a series of button UI widgets on the same x pos.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         offset_x = 0</span>
<span class="c1">#         container = self.get_container()</span>
<span class="c1">#         buttons = {}</span>
<span class="c1">#</span>
<span class="c1">#         for button_name in button_names:</span>
<span class="c1">#             # split the prefix from the name</span>
<span class="c1">#             try:</span>
<span class="c1">#                 prefix, key, name = button_name.lower().split(&quot;#&quot;)</span>
<span class="c1">#             except ValueError:</span>
<span class="c1">#                 # if no prefix</span>
<span class="c1">#                 name = button_name.lower()</span>
<span class="c1">#                 key = button_name</span>
<span class="c1">#</span>
<span class="c1">#             # ensure the object ID has no spaces</span>
<span class="c1">#             object_id = button_name.replace(&quot; &quot;, &quot;_&quot;)</span>
<span class="c1">#</span>
<span class="c1">#             # create the button</span>
<span class="c1">#             button_rect = pygame.Rect((x + offset_x, y), (width, height))</span>
<span class="c1">#             button = UIButton(button_rect, name, self.ui_manager, container=container,</span>
<span class="c1">#                               parent_element=self, object_id=object_id)</span>
<span class="c1">#             offset_x += width</span>
<span class="c1">#             buttons[object_id] = button</span>
<span class="c1">#</span>
<span class="c1">#         return buttons</span>
<span class="c1">#</span>
<span class="c1">#     ############### LOAD ###################</span>
<span class="c1">#</span>
<span class="c1">#     def _load_field_options(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Maps the various data keys to their related (options, dataclass). The dataclass is only provided if the key</span>
<span class="c1">#         relates to sub-details that need adding. E.g. effects: (EffectType.__dict__.keys(), EffectData). Loads</span>
<span class="c1">#         details into self.field_options</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         get_members = utility.get_class_members</span>
<span class="c1">#</span>
<span class="c1">#         affliction_options = [key for key in self.all_data[&quot;afflictions&quot;].keys()]</span>
<span class="c1">#         aspect_options = [key for key in self.all_data[&quot;aspects&quot;].keys()]</span>
<span class="c1">#         effect_options = get_members(EffectType)</span>
<span class="c1">#         primary_stat_options = get_members(PrimaryStat)</span>
<span class="c1">#         secondary_stat_options = get_members(SecondaryStat)</span>
<span class="c1">#         resource_options = get_members(Resource)</span>
<span class="c1">#         bool_options = [&quot;True&quot;, &quot;False&quot;]</span>
<span class="c1">#         skill_options = [key for key in self.all_data[&quot;skills&quot;].keys()]</span>
<span class="c1">#</span>
<span class="c1">#         field_options = {</span>
<span class="c1">#             &quot;effects&quot;: (effect_options, EffectData()),</span>
<span class="c1">#             &quot;affliction_name&quot;: (affliction_options, None),</span>
<span class="c1">#             &quot;aspect_name&quot;: (aspect_options, None),</span>
<span class="c1">#             &quot;damage_type&quot;: (get_members(DamageType), None),</span>
<span class="c1">#             &quot;effect_type&quot;: (effect_options, None),</span>
<span class="c1">#             &quot;stat_to_affect&quot;: (primary_stat_options + secondary_stat_options, None),</span>
<span class="c1">#             &quot;stat_to_target&quot;: (primary_stat_options, None),</span>
<span class="c1">#             &quot;activate_target_tags&quot;: (get_members(TargetTag), None),</span>
<span class="c1">#             &quot;mod_stat&quot;: (primary_stat_options + secondary_stat_options, None),</span>
<span class="c1">#             &quot;blocks_movement&quot;: (bool_options, None),</span>
<span class="c1">#             &quot;blocks_sight&quot;: (bool_options, None),</span>
<span class="c1">#             &quot;category&quot;: (get_members(AfflictionCategory), None),</span>
<span class="c1">#             &quot;cause&quot;: (affliction_options + effect_options + skill_options, None),  # interaction trigger</span>
<span class="c1">#             &quot;primary_stat_type&quot;: (primary_stat_options, None),</span>
<span class="c1">#             &quot;secondary_stat_type&quot;: (secondary_stat_options, None),</span>
<span class="c1">#             &quot;action&quot;: (affliction_options + effect_options + skill_options, None),  # gods attitudes on things</span>
<span class="c1">#             &quot;skill_key&quot;: (skill_options, None),</span>
<span class="c1">#             &quot;known_skills&quot;: (skill_options, None),</span>
<span class="c1">#             &quot;expiry_type&quot;: (get_members(ProjectileExpiry), None),</span>
<span class="c1">#             &quot;resource_type&quot;: (resource_options, None),</span>
<span class="c1">#             &quot;shape&quot;: (get_members(Shape), None),</span>
<span class="c1">#             &quot;target_directions&quot;: (get_members(Direction), None),</span>
<span class="c1">#             &quot;terrain_collision&quot;: (get_members(TerrainCollision), None),</span>
<span class="c1">#             &quot;travel_method&quot;: (get_members(TravelMethod), None),</span>
<span class="c1">#             &quot;attitudes&quot;: (affliction_options + effect_options + skill_options, AttitudeData()),</span>
<span class="c1">#             &quot;interventions&quot;: (skill_options, InterventionData()),</span>
<span class="c1">#             &quot;skills&quot;: (&quot;&quot;, SkillData()),</span>
<span class="c1">#             &quot;afflictions&quot;: (&quot;&quot;, AfflictionData()),</span>
<span class="c1">#             &quot;aspects&quot;: (&quot;&quot;, TerrainData()),</span>
<span class="c1">#             &quot;base_stats_primary&quot;: (&quot;&quot;, BasePrimaryStatData()),</span>
<span class="c1">#             &quot;base_stats_secondary&quot;: (&quot;&quot;, BaseSecondaryStatData()),</span>
<span class="c1">#             &quot;homelands&quot;: (&quot;&quot;, TraitData()),</span>
<span class="c1">#             &quot;peoples&quot;: (&quot;&quot;, TraitData()),</span>
<span class="c1">#             &quot;savvys&quot;: (&quot;&quot;, TraitData()),</span>
<span class="c1">#             &quot;gods&quot;: (&quot;&quot;, GodData())</span>
<span class="c1">#         }</span>
<span class="c1">#</span>
<span class="c1">#         self.field_options = field_options</span>
<span class="c1">#</span>
<span class="c1">#     def _load_details(self, primary_or_secondary: str, data_instance: str, secondary_keys: Tuple[str, str] = None):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Load details of the specified instance into the primary or secondary section</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         if secondary_keys:</span>
<span class="c1">#             secondary_key, instance_key = secondary_keys</span>
<span class="c1">#         else:</span>
<span class="c1">#             secondary_key = instance_key = &quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         # get initial pos info</span>
<span class="c1">#         if primary_or_secondary == &quot;primary&quot;:</span>
<span class="c1">#             start_x = self.primary_x</span>
<span class="c1">#             start_y = self.primary_y</span>
<span class="c1">#             row_width = self.primary_width</span>
<span class="c1">#             self.primary_data_fields = {}</span>
<span class="c1">#         else:</span>
<span class="c1">#             start_x = self.secondary_x</span>
<span class="c1">#             start_y = self.secondary_y</span>
<span class="c1">#             row_width = self.secondary_width</span>
<span class="c1">#             self.secondary_data_fields = {}</span>
<span class="c1">#</span>
<span class="c1">#         # get any info we can get ahead of time</span>
<span class="c1">#         container = self.get_container()</span>
<span class="c1">#         manager = self.ui_manager</span>
<span class="c1">#         row_height = self.row_height</span>
<span class="c1">#         current_y = start_y</span>
<span class="c1">#         data_fields = {}</span>
<span class="c1">#         all_data = self.all_data</span>
<span class="c1">#         category = self.current_data_category</span>
<span class="c1">#         instance = data_instance</span>
<span class="c1">#         field_options = self.field_options</span>
<span class="c1">#</span>
<span class="c1">#         # point to the required dataclasses</span>
<span class="c1">#         if primary_or_secondary == &quot;secondary&quot; and secondary_key != &quot;&quot; and instance_key != &quot;&quot;:</span>
<span class="c1">#             instance_dict = getattr(all_data[category][instance], secondary_key)</span>
<span class="c1">#</span>
<span class="c1">#             # see if we have existing values</span>
<span class="c1">#             try:</span>
<span class="c1">#                 inner_dataclass = instance_dict[instance_key.lower()]</span>
<span class="c1">#</span>
<span class="c1">#             except KeyError:</span>
<span class="c1">#                 # get the data class from the possible field options</span>
<span class="c1">#                 _key, inner_dataclass = field_options[secondary_key]</span>
<span class="c1">#</span>
<span class="c1">#                 # assign the key</span>
<span class="c1">#                 instance_dict[instance_key] = inner_dataclass</span>
<span class="c1">#</span>
<span class="c1">#         elif primary_or_secondary == &quot;secondary&quot; and not secondary_key:</span>
<span class="c1">#             instance_dict = getattr(all_data[category][instance], self.current_primary_field)</span>
<span class="c1">#             inner_dataclass = instance_dict[self.key_being_edited]</span>
<span class="c1">#</span>
<span class="c1">#         else:</span>
<span class="c1">#             # handle a new data instance by getting the relevant dataclass</span>
<span class="c1">#             if instance == &quot;new&quot;:</span>
<span class="c1">#                 outer_dict = all_data[category]</span>
<span class="c1">#                 if category in field_options:</span>
<span class="c1">#                     options, inner_dataclass = field_options[category]</span>
<span class="c1">#</span>
<span class="c1">#                     # assign the key</span>
<span class="c1">#                     outer_dict[&quot;new&quot;] = inner_dataclass</span>
<span class="c1">#</span>
<span class="c1">#             else:</span>
<span class="c1">#                 inner_dataclass = all_data[category][instance]</span>
<span class="c1">#</span>
<span class="c1">#         # convert dataclass to dict to loop values</span>
<span class="c1">#         data_dict = dataclasses.asdict(inner_dataclass)</span>
<span class="c1">#</span>
<span class="c1">#         # create data fields</span>
<span class="c1">#         for key, value in data_dict.items():</span>
<span class="c1">#             try:</span>
<span class="c1">#                 if key in field_options:</span>
<span class="c1">#                     options, secondary_fields = field_options[key]</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     options = []</span>
<span class="c1">#                     secondary_fields = &quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#                 # modify key to include the prefix</span>
<span class="c1">#                 prefix_key = primary_or_secondary + &quot;#&quot; + key</span>
<span class="c1">#</span>
<span class="c1">#                 # have we identified the secondary fields?</span>
<span class="c1">#                 if secondary_fields != &quot;&quot;:</span>
<span class="c1">#                     data_field = self._create_edit_detail_field(prefix_key, value, options, start_x, current_y,</span>
<span class="c1">#                                                                 row_width, row_height, container, manager)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     if options:</span>
<span class="c1">#                         # if key name is plural</span>
<span class="c1">#                         if key[len(key) - 1:] == &quot;s&quot;:</span>
<span class="c1">#                             data_field = self._create_multiple_from_options_field(prefix_key, value, options,</span>
<span class="c1">#                                                                                   start_x,</span>
<span class="c1">#                                                                                   current_y, row_width, row_height,</span>
<span class="c1">#                                                                                   container, manager)</span>
<span class="c1">#                         # singular name, only pick one</span>
<span class="c1">#                         else:</span>
<span class="c1">#                             data_field = self._create_one_from_options_field(prefix_key, value, options, start_x,</span>
<span class="c1">#                                                                              current_y, row_width, row_height,</span>
<span class="c1">#                                                                              container, manager)</span>
<span class="c1">#                     # no options so it must be a text field</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         data_field = self._create_text_entry_field(prefix_key, value, start_x, current_y, row_width,</span>
<span class="c1">#                                                                    row_height, container, manager)</span>
<span class="c1">#</span>
<span class="c1">#                 # increment Y</span>
<span class="c1">#                 current_y += data_field.height + 1</span>
<span class="c1">#</span>
<span class="c1">#                 # save the data field</span>
<span class="c1">#                 data_fields[key] = data_field</span>
<span class="c1">#             except ValueError as e:</span>
<span class="c1">#                 logging.warning(f&quot;Error ({e}) trying to create_entity data field for {key}:{value}.&quot;)</span>
<span class="c1">#</span>
<span class="c1">#         # update the main record</span>
<span class="c1">#         if primary_or_secondary == &quot;primary&quot;:</span>
<span class="c1">#             self.primary_data_fields = {}</span>
<span class="c1">#             self.primary_data_fields = data_fields</span>
<span class="c1">#         elif primary_or_secondary == &quot;secondary&quot;:</span>
<span class="c1">#             self.secondary_data_fields = {}</span>
<span class="c1">#             self.secondary_data_fields = data_fields</span>
<span class="c1">#         else:</span>
<span class="c1">#             self.primary_data_fields = {}</span>
<span class="c1">#             self.primary_data_fields = data_fields</span>
<span class="c1">#</span>
<span class="c1">#         # take note of the highest used y, for the scroll bar</span>
<span class="c1">#         self.max_y = max(current_y, self.max_y)</span>
<span class="c1">#</span>
<span class="c1">#     def _load_library_data(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Load all of the data options into self.all_data</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         self.all_data = {</span>
<span class="c1">#             &quot;base_stats_primary&quot;: library.get_primary_stats_data(),</span>
<span class="c1">#             &quot;base_stats_secondary&quot;: library.get_secondary_stats_data(),</span>
<span class="c1">#             &quot;homelands&quot;: library.get_homelands_data(),</span>
<span class="c1">#             &quot;peoples&quot;: library.get_peoples_data(),</span>
<span class="c1">#             &quot;savvys&quot;: library.get_savvys_data(),</span>
<span class="c1">#             &quot;afflictions&quot;: library.get_afflictions_data(),</span>
<span class="c1">#             &quot;skills&quot;: library.get_skills_data(),</span>
<span class="c1">#             &quot;aspects&quot;: library.get_aspects_data(),</span>
<span class="c1">#             &quot;gods&quot;: library.get_gods_data()</span>
<span class="c1">#         }</span>
<span class="c1">#</span>
<span class="c1">#     ############## CLEAR #####################</span>
<span class="c1">#</span>
<span class="c1">#     def kill(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Clear all held data.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         if self.category_selector:</span>
<span class="c1">#             self.category_selector.kill()</span>
<span class="c1">#             self.category_selector = None</span>
<span class="c1">#         if self.instance_selector:</span>
<span class="c1">#             self.instance_selector.kill()</span>
<span class="c1">#             self.instance_selector = None</span>
<span class="c1">#         if self.primary_data_fields:</span>
<span class="c1">#             self._kill_details_fields(&quot;primary&quot;)</span>
<span class="c1">#             self.primary_data_fields = {}</span>
<span class="c1">#         if self.secondary_data_fields:</span>
<span class="c1">#             self._kill_details_fields(&quot;secondary&quot;)</span>
<span class="c1">#             self.secondary_data_fields = {}</span>
<span class="c1">#</span>
<span class="c1">#         super().kill()</span>
<span class="c1">#</span>
<span class="c1">#     def _kill_details_fields(self, primary_or_secondary: str):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Clear currently held details in the given dict of data fields.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         if primary_or_secondary == &quot;primary&quot;:</span>
<span class="c1">#             self.current_primary_field = &quot;&quot;</span>
<span class="c1">#             data_fields = self.primary_data_fields</span>
<span class="c1">#         elif primary_or_secondary == &quot;secondary&quot;:</span>
<span class="c1">#             self.current_secondary_field = &quot;&quot;</span>
<span class="c1">#             data_fields = self.secondary_data_fields</span>
<span class="c1">#         else:</span>
<span class="c1">#             data_fields = self.primary_data_fields</span>
<span class="c1">#</span>
<span class="c1">#         # clear the data fields</span>
<span class="c1">#         for data_field in data_fields.values():</span>
<span class="c1">#             data_field.kill()</span>
<span class="c1">#</span>
<span class="c1">#         # clear the dict</span>
<span class="c1">#         if primary_or_secondary == &quot;primary&quot;:</span>
<span class="c1">#             self.primary_data_fields = {}</span>
<span class="c1">#         elif primary_or_secondary == &quot;secondary&quot;:</span>
<span class="c1">#             self.secondary_data_fields = {}</span>
<span class="c1">#         else:</span>
<span class="c1">#             self.primary_data_fields = {}</span>
<span class="c1">#</span>
<span class="c1">#     ############ SAVE ##################</span>
<span class="c1">#</span>
<span class="c1">#     def _save_updated_field(self, primary_or_secondary, data_field: DataField, updated_value: Any):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Save the updated value to the main dict held in self.all_data</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         # if primary then grab from 4th layer; all_data:category:instance:data_field</span>
<span class="c1">#         if primary_or_secondary == &quot;primary&quot;:</span>
<span class="c1">#             # if we have a new data set</span>
<span class="c1">#             if self.current_data_instance == &quot;new&quot;:</span>
<span class="c1">#                 # if we have changed the name</span>
<span class="c1">#                 if data_field.key == &quot;name&quot;:</span>
<span class="c1">#                     # move the &quot;new&quot; key to a key using the name</span>
<span class="c1">#                     name = data_field.input_element.text.lower()  # It will be a text field, as the name always is</span>
<span class="c1">#                     self.all_data[self.current_data_category][name] = self.all_data[self.current_data_category].pop(</span>
<span class="c1">#                         self.current_data_instance)</span>
<span class="c1">#</span>
<span class="c1">#                     # update current instance</span>
<span class="c1">#                     self.current_data_instance = name</span>
<span class="c1">#</span>
<span class="c1">#             # set the primary value</span>
<span class="c1">#             setattr(self.all_data[self.current_data_category][self.current_data_instance], data_field.key,</span>
<span class="c1">#                     updated_value)</span>
<span class="c1">#</span>
<span class="c1">#         else:</span>
<span class="c1">#             # get the selected primary field</span>
<span class="c1">#             primary = getattr(self.all_data[self.current_data_category][self.current_data_instance],</span>
<span class="c1">#                               self.primary_data_fields[self.current_primary_field].key)</span>
<span class="c1">#             setattr(primary[self.key_being_edited], data_field.key, updated_value)</span>
<span class="c1">#</span>
<span class="c1">#         # save back to json</span>
<span class="c1">#         with open(f&quot;data/game/{self.current_data_category}.json&quot;, &quot;w&quot;) as file:</span>
<span class="c1">#             json.dump(self.all_data[self.current_data_category], file, sort_keys=True, indent=4,</span>
<span class="c1">#                       cls=ExtendedJsonEncoder)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># class DataField:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     Holds a set of related data and ui_manager elements</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     def __init__(self, primary_or_secondary: str, key: str, value: Any, value_as_str: str, value_type, labels: List,</span>
<span class="c1">#         height: int, input_element=None, buttons: Dict[str, UIButton] = None, options: List = None):</span>
<span class="c1">#         self.primary_or_secondary = primary_or_secondary</span>
<span class="c1">#         self.key = key</span>
<span class="c1">#         self.value = value</span>
<span class="c1">#         self.value_as_str = value_as_str</span>
<span class="c1">#         self.value_type = value_type</span>
<span class="c1">#         self.options = options</span>
<span class="c1">#         self.height = height</span>
<span class="c1">#</span>
<span class="c1">#         # ui_manager elements</span>
<span class="c1">#         self.input_element = input_element</span>
<span class="c1">#         self.labels = labels</span>
<span class="c1">#         self.buttons = buttons</span>
<span class="c1">#</span>
<span class="c1">#     def kill(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Kill all held ui_manager elements</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         if self.input_element:</span>
<span class="c1">#             self.input_element.kill()</span>
<span class="c1">#             self.input_element = None</span>
<span class="c1">#</span>
<span class="c1">#         if self.labels:</span>
<span class="c1">#             for label in self.labels:</span>
<span class="c1">#                 label.kill()</span>
<span class="c1">#             self.labels = None</span>
<span class="c1">#</span>
<span class="c1">#         if self.buttons:</span>
<span class="c1">#             for key, button in self.buttons.items():</span>
<span class="c1">#                 button.kill()</span>
<span class="c1">#             self.buttons = None</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2019-2020, Josh Snaith

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>