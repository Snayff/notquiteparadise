
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../../../../../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../../../../../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../../../../../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../../../../../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../../../../../_static/javascripts/modernizr.js"></script>
  
  
  
    <title>scripts.engine.ui.elements.data_editor &#8212; NotQuiteParadise  documentation</title>
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/material.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../_static/jquery.js"></script>
    <script src="../../../../../_static/underscore.js"></script>
    <script src="../../../../../_static/doctools.js"></script>
    <script src="../../../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=deep-purple data-md-color-accent=deep-orange>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#_modules/scripts/engine/ui/elements/data_editor" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../../../../../index.html" title="NotQuiteParadise  documentation"
           class="md-header-nav__button md-logo">
          
            <i class="md-icon">&#xe869</i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">Not Quite Paradise</span>
          <span class="md-header-nav__topic"> scripts.engine.ui.elements.data_editor </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../../../../../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/Snayff/notquiteparadise" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Not Quite Paradise
  </div>
</a>
          </div>
        </div>
      
      
  
  <script src="../../../../../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../../../../../"versions.json"",
        target_loc = "../../../../../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../../../../../index.html" class="md-tabs__link">NotQuiteParadise  documentation</a></li>
          <li class="md-tabs__item"><a href="../../../../index.html" class="md-tabs__link">Module code</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../../../../../index.html" title="NotQuiteParadise documentation" class="md-nav__button md-logo">
      
        <i class="md-icon">&#xe869</i>
      
    </a>
    <a href="../../../../../index.html"
       title="NotQuiteParadise documentation">Not Quite Paradise</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/Snayff/notquiteparadise" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Not Quite Paradise
  </div>
</a>
    </div>
  
  

  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
    
      <a href="../../../../../info/_info.html" class="md-nav__link">Info</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../../engine/_engine.html" class="md-nav__link">Engine API</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../../../../../nqp/_nqp.html" class="md-nav__link">NQP Documentation</a>
      
    
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
  <ul class="md-nav__list" data-md-scrollfix="">
    

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  <h1 id="modules-scripts-engine-ui-elements-data-editor--page-root">Source code for scripts.engine.ui.elements.data_editor</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">dataclasses</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span>

<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">import</span> <span class="nn">pygame_gui</span>
<span class="kn">from</span> <span class="nn">pygame_gui.core</span> <span class="kn">import</span> <span class="n">UIContainer</span>
<span class="kn">from</span> <span class="nn">pygame_gui.elements</span> <span class="kn">import</span> <span class="n">UIButton</span><span class="p">,</span> <span class="n">UIDropDownMenu</span><span class="p">,</span> <span class="n">UILabel</span><span class="p">,</span> <span class="n">UITextEntryLine</span><span class="p">,</span> <span class="n">UIWindow</span>

<span class="kn">from</span> <span class="nn">scripts.engine</span> <span class="kn">import</span> <span class="n">utility</span>
<span class="kn">from</span> <span class="nn">scripts.engine.core.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AfflictionCategory</span><span class="p">,</span>
    <span class="n">DamageType</span><span class="p">,</span>
    <span class="n">Direction</span><span class="p">,</span>
    <span class="n">EffectType</span><span class="p">,</span>
    <span class="n">PrimaryStat</span><span class="p">,</span>
    <span class="n">ProjectileExpiry</span><span class="p">,</span>
    <span class="n">Resource</span><span class="p">,</span>
    <span class="n">SecondaryStat</span><span class="p">,</span>
    <span class="n">Shape</span><span class="p">,</span>
    <span class="n">TargetTag</span><span class="p">,</span>
    <span class="n">TerrainCollision</span><span class="p">,</span>
    <span class="n">TravelMethod</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">scripts.engine.core.definitions</span> <span class="kn">import</span> <span class="n">EffectData</span><span class="p">,</span> <span class="n">SkillData</span><span class="p">,</span> <span class="n">TraitData</span>
<span class="kn">from</span> <span class="nn">scripts.engine.core.extend_json</span> <span class="kn">import</span> <span class="n">ExtendedJsonEncoder</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

    <span class="kn">from</span> <span class="nn">pygame_gui</span> <span class="kn">import</span> <span class="n">UIManager</span>


<div class="viewcode-block" id="DataEditor"><a class="viewcode-back" href="../../../../../scripts.engine.ui.elements.html#scripts.engine.ui.elements.data_editor.DataEditor">[docs]</a><span class="k">class</span> <span class="nc">DataEditor</span><span class="p">(</span><span class="n">UIWindow</span><span class="p">):</span>
    <span class="k">pass</span>
    <span class="c1">#     """</span>
    <span class="c1">#     Dev tool to allow creating and editing data.</span>
    <span class="c1">#     """</span>
    <span class="c1">#</span>
    <span class="c1">#     def __init__(self, rect, manager):</span>
    <span class="c1">#         super().__init__(rect, manager, "data_editor")</span>
    <span class="c1">#</span>
    <span class="c1">#         # data holders</span>
    <span class="c1">#         self.all_data: Dict[str, Dict[str, dataclass()]] = {}</span>
    <span class="c1">#         self.current_data_category: str = None</span>
    <span class="c1">#         self.current_data_instance: str = None</span>
    <span class="c1">#         self.current_primary_field: str = None</span>
    <span class="c1">#         self.current_secondary_field: str = None</span>
    <span class="c1">#         self.key_being_edited: str = None</span>
    <span class="c1">#         self.field_options: Dict[str, Tuple[List[str], Optional[dataclass]]] = {}</span>
    <span class="c1">#</span>
    <span class="c1">#         # data selectors</span>
    <span class="c1">#         self.category_selector: UIDropDownMenu = None</span>
    <span class="c1">#         self.instance_selector: UIDropDownMenu = None</span>
    <span class="c1">#</span>
    <span class="c1">#         # dicts of data fields</span>
    <span class="c1">#         self.primary_data_fields: Dict[str, DataField] = {}</span>
    <span class="c1">#         self.secondary_data_fields: Dict[str, DataField] = {}</span>
    <span class="c1">#</span>
    <span class="c1">#         # size info</span>
    <span class="c1">#         self.start_x = 2</span>
    <span class="c1">#         self.start_y = 2</span>
    <span class="c1">#         self.width = self.rect.width</span>
    <span class="c1">#         self.height = self.rect.height</span>
    <span class="c1">#         self.row_height = 25</span>
    <span class="c1">#         self.max_rows = self.height // self.row_height</span>
    <span class="c1">#         self.selectors_end_y = self.start_y + (self.row_height * 2)  # 2 is number of selectors</span>
    <span class="c1">#</span>
    <span class="c1">#         self.primary_x = self.start_x</span>
    <span class="c1">#         self.primary_y = self.selectors_end_y</span>
    <span class="c1">#         self.primary_width = self.width // 2</span>
    <span class="c1">#</span>
    <span class="c1">#         self.secondary_x = self.primary_x + self.primary_width</span>
    <span class="c1">#         self.secondary_y = self.selectors_end_y</span>
    <span class="c1">#         self.secondary_width = self.width - self.primary_width</span>
    <span class="c1">#</span>
    <span class="c1">#         self.label_width_mod = 0.3  # decimal % of row width that label takes up</span>
    <span class="c1">#</span>
    <span class="c1">#         self.max_y = self.height</span>
    <span class="c1">#</span>
    <span class="c1">#         # get the data &amp; field options</span>
    <span class="c1">#         self._load_library_data()</span>
    <span class="c1">#         self._load_field_options()</span>
    <span class="c1">#</span>
    <span class="c1">#         # display the initial selector</span>
    <span class="c1">#         self.category_selector = self._create_data_category_selector()</span>
    <span class="c1">#</span>
<div class="viewcode-block" id="DataEditor.update"><a class="viewcode-back" href="../../../../../scripts.engine.ui.elements.html#scripts.engine.ui.elements.data_editor.DataEditor.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_delta</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">pass</span></div>

    <span class="c1">#         """</span>
    <span class="c1">#         Update based on current state and data. Run every frame.</span>
    <span class="c1">#         """</span>
    <span class="c1">#         super().update(time_delta)</span>
    <span class="c1">#</span>
<div class="viewcode-block" id="DataEditor.handle_events"><a class="viewcode-back" href="../../../../../scripts.engine.ui.elements.html#scripts.engine.ui.elements.data_editor.DataEditor.handle_events">[docs]</a>    <span class="k">def</span> <span class="nf">handle_events</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">pass</span></div></div>


<span class="c1">#         """</span>
<span class="c1">#         Handle events created by this UI widget</span>
<span class="c1">#         """</span>
<span class="c1">#         ui_object_id = event.ui_object_id</span>
<span class="c1">#         new_value = None</span>
<span class="c1">#         data_field = None</span>
<span class="c1">#</span>
<span class="c1">#         # new selection in instance_selector</span>
<span class="c1">#         if ui_object_id == "category_selector":</span>
<span class="c1">#             if event.user_type == pygame_gui.UI_DROP_DOWN_MENU_CHANGED:</span>
<span class="c1">#                 if self.category_selector.selected_option != self.current_data_category:</span>
<span class="c1">#                     self._select_new_category(self.category_selector.selected_option)</span>
<span class="c1">#</span>
<span class="c1">#         # new selection in instance_selector</span>
<span class="c1">#         if ui_object_id == "instance_selector":</span>
<span class="c1">#             if event.user_type == pygame_gui.UI_DROP_DOWN_MENU_CHANGED:</span>
<span class="c1">#                 if self.instance_selector.selected_option != self.current_data_instance:</span>
<span class="c1">#                     self._select_new_instance(self.instance_selector.selected_option)</span>
<span class="c1">#</span>
<span class="c1">#         # new selection in a different, non-selector dropdown</span>
<span class="c1">#         if ui_object_id != "instance_selector" and ui_object_id != "category_selector":</span>
<span class="c1">#             if event.user_type == pygame_gui.UI_DROP_DOWN_MENU_CHANGED:</span>
<span class="c1">#                 data_field, new_value = self._process_dropdown_change(ui_object_id)</span>
<span class="c1">#</span>
<span class="c1">#         # handle text field finished typing (triggers on enter press)</span>
<span class="c1">#         if event.user_type == pygame_gui.UI_TEXT_ENTRY_FINISHED:</span>
<span class="c1">#             data_field, new_value = self._process_textbox_change(ui_object_id)</span>
<span class="c1">#</span>
<span class="c1">#         # handle triggers for secondary details</span>
<span class="c1">#         prefix = "edit#"</span>
<span class="c1">#         if ui_object_id[:len(prefix)] == prefix:</span>
<span class="c1">#             data_field, new_value = self._process_edit_action(ui_object_id)</span>
<span class="c1">#</span>
<span class="c1">#         # handle multiple choice to toggle the value</span>
<span class="c1">#         prefix = "multi#"</span>
<span class="c1">#         if ui_object_id[:len(prefix)] == prefix:</span>
<span class="c1">#             data_field, new_value = self._process_multi_action(ui_object_id)</span>
<span class="c1">#</span>
<span class="c1">#         # update selected fields</span>
<span class="c1">#         if data_field:</span>
<span class="c1">#             if data_field.primary_or_secondary == "primary":</span>
<span class="c1">#                 self.current_primary_field = data_field.key</span>
<span class="c1">#             else:</span>
<span class="c1">#                 self.current_secondary_field = data_field.key</span>
<span class="c1">#</span>
<span class="c1">#             if new_value is not None:</span>
<span class="c1">#                 # process the update and reload</span>
<span class="c1">#                 primary_or_secondary = data_field.primary_or_secondary</span>
<span class="c1">#</span>
<span class="c1">#                 self._save_updated_field(primary_or_secondary, data_field, new_value)</span>
<span class="c1">#</span>
<span class="c1">#                 # clear existing</span>
<span class="c1">#                 self._kill_details_fields(primary_or_secondary)</span>
<span class="c1">#</span>
<span class="c1">#                 # reload to reflect new changes</span>
<span class="c1">#                 self._load_details(primary_or_secondary, self.current_data_instance)</span>
<span class="c1">#</span>
<span class="c1">#     ################# INTERACT ################</span>
<span class="c1">#</span>
<span class="c1">#     def _select_new_category(self, category: str):</span>
<span class="c1">#         """</span>
<span class="c1">#         Select new category, clear existing data fields and create_entity new instance options from category.</span>
<span class="c1">#         """</span>
<span class="c1">#         self.current_data_category = category</span>
<span class="c1">#</span>
<span class="c1">#         # clear existing details fields</span>
<span class="c1">#         self._kill_details_fields("primary")</span>
<span class="c1">#         self._kill_details_fields("secondary")</span>
<span class="c1">#</span>
<span class="c1">#         # clear existing instance selector</span>
<span class="c1">#         if self.instance_selector:</span>
<span class="c1">#             self.instance_selector.kill()</span>
<span class="c1">#             self.instance_selector = None</span>
<span class="c1">#</span>
<span class="c1">#         # create new instance selector</span>
<span class="c1">#         options: List[str] = []</span>
<span class="c1">#         options.extend(key for key in self.all_data[self.current_data_category].keys())</span>
<span class="c1">#         options.sort()</span>
<span class="c1">#         self.instance_selector = self._create_data_instance_selector(options)</span>
<span class="c1">#</span>
<span class="c1">#     def _select_new_instance(self, instance: str):</span>
<span class="c1">#         """</span>
<span class="c1">#         Select new data instance and clear current data fields before loading primary data details</span>
<span class="c1">#         """</span>
<span class="c1">#         # clear existing details fields</span>
<span class="c1">#         self._kill_details_fields("primary")</span>
<span class="c1">#         self._kill_details_fields("secondary")</span>
<span class="c1">#</span>
<span class="c1">#         # create new</span>
<span class="c1">#         self.current_data_instance = instance</span>
<span class="c1">#         self._load_details("primary", self.current_data_instance)</span>
<span class="c1">#</span>
<span class="c1">#     def _process_dropdown_change(self, object_id: str) -&gt; Tuple[Optional[DataField], Any]:</span>
<span class="c1">#         """</span>
<span class="c1">#         Check if new option selected in dropdown and if so return data_field and new value</span>
<span class="c1">#         """</span>
<span class="c1">#         key = object_id</span>
<span class="c1">#</span>
<span class="c1">#         try:</span>
<span class="c1">#             data_field = self.secondary_data_fields[key]</span>
<span class="c1">#         except KeyError:</span>
<span class="c1">#             data_field = self.primary_data_fields[key]</span>
<span class="c1">#</span>
<span class="c1">#         new_value = data_field.input_element.selected_option</span>
<span class="c1">#</span>
<span class="c1">#         # check the value has changed</span>
<span class="c1">#         if new_value != data_field.value:</span>
<span class="c1">#             return data_field, new_value</span>
<span class="c1">#</span>
<span class="c1">#         return None, None</span>
<span class="c1">#</span>
<span class="c1">#     def _process_textbox_change(self, object_id: str) -&gt; Tuple[Optional[DataField], Any]:</span>
<span class="c1">#         """</span>
<span class="c1">#         Check if text has changed and return data field and new value"""</span>
<span class="c1">#         key = object_id</span>
<span class="c1">#         try:</span>
<span class="c1">#             data_field = self.secondary_data_fields[key]</span>
<span class="c1">#         except KeyError:</span>
<span class="c1">#             data_field = self.primary_data_fields[key]</span>
<span class="c1">#</span>
<span class="c1">#         new_value = data_field.input_element.text</span>
<span class="c1">#</span>
<span class="c1">#         # check the value has changed</span>
<span class="c1">#         if new_value != data_field.value:</span>
<span class="c1">#             return data_field, new_value</span>
<span class="c1">#</span>
<span class="c1">#         return None, None</span>
<span class="c1">#</span>
<span class="c1">#     def _process_edit_action(self, object_id: str) -&gt; Tuple[Optional[DataField], None]:</span>
<span class="c1">#         # get the key</span>
<span class="c1">#         prefix, key, _object_id = object_id.split("#")</span>
<span class="c1">#</span>
<span class="c1">#         # clear existing details fields N.B. edit can only be in primary</span>
<span class="c1">#         self._kill_details_fields("secondary")</span>
<span class="c1">#</span>
<span class="c1">#         #  load secondary details</span>
<span class="c1">#         self._load_details("secondary", self.current_data_instance, (key, _object_id))</span>
<span class="c1">#</span>
<span class="c1">#         self.key_being_edited = _object_id</span>
<span class="c1">#</span>
<span class="c1">#         data_field = self.primary_data_fields[key]</span>
<span class="c1">#         return data_field, None</span>
<span class="c1">#</span>
<span class="c1">#     def _process_multi_action(self, object_id: str) -&gt; Tuple[Optional[DataField], Any]:</span>
<span class="c1">#         """</span>
<span class="c1">#         Toggle selected option in the relevant field"""</span>
<span class="c1">#         # get the key</span>
<span class="c1">#         prefix, key, _object_id = object_id.split("#")</span>
<span class="c1">#</span>
<span class="c1">#         try:</span>
<span class="c1">#             data_field = self.secondary_data_fields[key]</span>
<span class="c1">#         except KeyError:</span>
<span class="c1">#             data_field = self.primary_data_fields[key]</span>
<span class="c1">#</span>
<span class="c1">#         # get current value</span>
<span class="c1">#         current_value: List = data_field.value</span>
<span class="c1">#         id_as_value = _object_id</span>
<span class="c1">#</span>
<span class="c1">#         if id_as_value in current_value:</span>
<span class="c1">#             current_value.remove(id_as_value)</span>
<span class="c1">#         else:</span>
<span class="c1">#             current_value.append(id_as_value)</span>
<span class="c1">#</span>
<span class="c1">#         new_value = current_value</span>
<span class="c1">#</span>
<span class="c1">#         return data_field, new_value</span>
<span class="c1">#</span>
<span class="c1">#     ############## CREATE ################</span>
<span class="c1">#</span>
<span class="c1">#     def _create_data_category_selector(self) -&gt; UIDropDownMenu:</span>
<span class="c1">#         """</span>
<span class="c1">#         Create the category selector drop down menu</span>
<span class="c1">#         """</span>
<span class="c1">#         # get options and sort alphabetically</span>
<span class="c1">#         options = [keys for keys in self.all_data.keys()]</span>
<span class="c1">#         options.sort()</span>
<span class="c1">#</span>
<span class="c1">#         rect = pygame.Rect((self.start_x, self.start_y), (self.width, self.row_height))</span>
<span class="c1">#</span>
<span class="c1">#         return UIDropDownMenu(options, "None", rect, self.ui_manager, container=self.get_container(),</span>
<span class="c1">#                               parent_element=self, object_id="category_selector")</span>
<span class="c1">#</span>
<span class="c1">#     def _create_data_instance_selector(self, options: List[str]) -&gt; UIDropDownMenu:</span>
<span class="c1">#         """</span>
<span class="c1">#         Create the instance selector drop down menu</span>
<span class="c1">#         """</span>
<span class="c1">#         rect = pygame.Rect((self.start_x, self.start_y + self.row_height), (self.width, self.row_height))</span>
<span class="c1">#</span>
<span class="c1">#         _options = options</span>
<span class="c1">#         _options.insert(0, "new")</span>
<span class="c1">#</span>
<span class="c1">#         return UIDropDownMenu(_options, "None", rect, self.ui_manager, container=self.get_container(),</span>
<span class="c1">#                               parent_element=self, object_id="instance_selector")</span>
<span class="c1">#</span>
<span class="c1">#     def _create_one_from_options_field(self, key: str, value: Any, options: List[str], x: int, y: int, width: int,</span>
<span class="c1">#             height: int, container: UIContainer, ui_manager: UIManager) -&gt; DataField:</span>
<span class="c1">#         """</span>
<span class="c1">#         Create a data field containing label, current value and a dropdown of possible options.</span>
<span class="c1">#         """</span>
<span class="c1">#         # split out the elements of the key</span>
<span class="c1">#         primary_or_secondary, _key = key.split("#")</span>
<span class="c1">#</span>
<span class="c1">#         labels = []</span>
<span class="c1">#         _options = [option.lower() for option in options]</span>
<span class="c1">#</span>
<span class="c1">#         # get value name</span>
<span class="c1">#         if value:</span>
<span class="c1">#             value_name = value</span>
<span class="c1">#         else:</span>
<span class="c1">#             value_name = "None"</span>
<span class="c1">#</span>
<span class="c1">#         # insert none option</span>
<span class="c1">#         _options.insert(0, "None")</span>
<span class="c1">#</span>
<span class="c1">#         _options.sort()</span>
<span class="c1">#</span>
<span class="c1">#         # create the key label</span>
<span class="c1">#         key_width = int(width * self.label_width_mod)</span>
<span class="c1">#         key_rect = pygame.Rect((x, y), (key_width, height))</span>
<span class="c1">#         key_label = UILabel(key_rect, _key, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#         labels.append(key_label)</span>
<span class="c1">#</span>
<span class="c1">#         # create the current values label</span>
<span class="c1">#         value_width = width - key_width</span>
<span class="c1">#         value_x = x + key_width</span>
<span class="c1">#         value_rect = pygame.Rect((value_x, y), (value_width, height))</span>
<span class="c1">#         value_label = UILabel(value_rect, value_name, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#         labels.append(value_label)</span>
<span class="c1">#</span>
<span class="c1">#         # create the option's dropdown, incremented by height</span>
<span class="c1">#         input_rect = pygame.Rect((x, y + height), (width, height))</span>
<span class="c1">#         input = UIDropDownMenu(_options, value_name, input_rect, ui_manager, container=container,</span>
<span class="c1">#                                parent_element=self, object_id=_key)</span>
<span class="c1">#</span>
<span class="c1">#         # create the data field</span>
<span class="c1">#         data_field = DataField(primary_or_secondary, _key, value, value_name, str, labels, height * 2,</span>
<span class="c1">#                                input_element=input, options=_options)</span>
<span class="c1">#</span>
<span class="c1">#         return data_field</span>
<span class="c1">#</span>
<span class="c1">#     def _create_edit_detail_field(self, key: str, value: Any, options: List[str], x: int, y: int, width: int,</span>
<span class="c1">#             height: int, container: UIContainer, ui_manager: UIManager) -&gt; DataField:</span>
<span class="c1">#         """</span>
<span class="c1">#         Create a data field containing label, current values and a row of buttons for possible options. Buttons are</span>
<span class="c1">#         prefixed with edit#</span>
<span class="c1">#         """</span>
<span class="c1">#         # split out the elements of the key</span>
<span class="c1">#         primary_or_secondary, _key = key.split("#")</span>
<span class="c1">#</span>
<span class="c1">#         labels = []</span>
<span class="c1">#         prefixed_options: List[str] = []</span>
<span class="c1">#         values_list: List[str] = []</span>
<span class="c1">#</span>
<span class="c1">#         # Turn value into a list of strings</span>
<span class="c1">#         prefixed_options.extend(f"edit#{_key}#{name.lower()}" for name in options)</span>
<span class="c1">#         if value:</span>
<span class="c1">#             values_list.extend(name for name in value.keys())</span>
<span class="c1">#</span>
<span class="c1">#         # sort lists alphabetically</span>
<span class="c1">#         prefixed_options.sort()</span>
<span class="c1">#         values_list.sort()</span>
<span class="c1">#</span>
<span class="c1">#         # create the key label</span>
<span class="c1">#         key_width = int(width * self.label_width_mod)</span>
<span class="c1">#         key_rect = pygame.Rect((x, y), (key_width, height))</span>
<span class="c1">#         key_label = UILabel(key_rect, _key, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#         labels.append(key_label)</span>
<span class="c1">#</span>
<span class="c1">#         # convert the list to a string</span>
<span class="c1">#         values_str = ", ".join(values_list)</span>
<span class="c1">#         values_str += ", "  # add comma to the end to help delimit when adding other values</span>
<span class="c1">#</span>
<span class="c1">#         # create the current values label</span>
<span class="c1">#         value_width = width - key_width</span>
<span class="c1">#         value_x = x + key_width</span>
<span class="c1">#         value_rect = pygame.Rect((value_x, y), (value_width, height))</span>
<span class="c1">#         value_label = UILabel(value_rect, values_str, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#         labels.append(value_label)</span>
<span class="c1">#</span>
<span class="c1">#         # determine how wide to make buttons</span>
<span class="c1">#         button_width = width // len(prefixed_options)</span>
<span class="c1">#</span>
<span class="c1">#         # create the option's buttons, incremented by height</span>
<span class="c1">#         buttons = self._create_row_of_buttons(prefixed_options, x, y + height, button_width, height)</span>
<span class="c1">#</span>
<span class="c1">#         # create the data field</span>
<span class="c1">#         data_field = DataField(primary_or_secondary, _key, value, values_str, Dict, labels, height * 2,</span>
<span class="c1">#                                buttons=buttons, options=prefixed_options)</span>
<span class="c1">#</span>
<span class="c1">#         return data_field</span>
<span class="c1">#</span>
<span class="c1">#     def _create_multiple_from_options_field(self, key: str, value: Any, options: List[str], x: int, y: int,</span>
<span class="c1">#             width: int, height: int, container: UIContainer, ui_manager: UIManager) -&gt; DataField:</span>
<span class="c1">#         """</span>
<span class="c1">#         Create a data field containing label, current values and a row of buttons for possible options. Button's</span>
<span class="c1">#         object_ids are prefixed with multi#</span>
<span class="c1">#         """</span>
<span class="c1">#         # split out the elements of the key</span>
<span class="c1">#         primary_or_secondary, _key = key.split("#")</span>
<span class="c1">#</span>
<span class="c1">#         labels = []</span>
<span class="c1">#         prefixed_options: List[str] = []</span>
<span class="c1">#         values_list: List[str] = []</span>
<span class="c1">#</span>
<span class="c1">#         # add prefix</span>
<span class="c1">#         prefixed_options.extend(f"multi#{_key}#{name.lower()}" for name in options)</span>
<span class="c1">#         values_list.extend(name for name in value)</span>
<span class="c1">#</span>
<span class="c1">#         # replace spaces with underscores as object_id doesnt like spaces</span>
<span class="c1">#         # values_list = [new_value.replace(" ", "_") for new_value in values_list]</span>
<span class="c1">#         # prefixed_options = [new_value.replace(" ", "_") for new_value in options]</span>
<span class="c1">#</span>
<span class="c1">#         # sort lists alphabetically</span>
<span class="c1">#         prefixed_options.sort()</span>
<span class="c1">#         values_list.sort()</span>
<span class="c1">#</span>
<span class="c1">#         # create the key label</span>
<span class="c1">#         key_width = int(width * self.label_width_mod)</span>
<span class="c1">#         key_rect = pygame.Rect((x, y), (key_width, height))</span>
<span class="c1">#         key_label = UILabel(key_rect, _key, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#         labels.append(key_label)</span>
<span class="c1">#</span>
<span class="c1">#         # convert the list to a string</span>
<span class="c1">#         values_str = ", ".join(values_list)</span>
<span class="c1">#</span>
<span class="c1">#         # add comma to the end to help delimit when adding other values, unless there are no values!</span>
<span class="c1">#         if values_str != "":</span>
<span class="c1">#             values_str += ", "</span>
<span class="c1">#</span>
<span class="c1">#         # create the current values label</span>
<span class="c1">#         value_width = width - key_width</span>
<span class="c1">#         value_x = x + key_width</span>
<span class="c1">#         value_rect = pygame.Rect((value_x, y), (value_width, height))</span>
<span class="c1">#         value_label = UILabel(value_rect, values_str, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#         labels.append(value_label)</span>
<span class="c1">#</span>
<span class="c1">#         # determine how wide to make buttons</span>
<span class="c1">#         button_width = width // len(prefixed_options)</span>
<span class="c1">#</span>
<span class="c1">#         # create the option's buttons, incremented by height</span>
<span class="c1">#         buttons = self._create_row_of_buttons(prefixed_options, x, y + height, button_width, height)</span>
<span class="c1">#</span>
<span class="c1">#         # create the data field</span>
<span class="c1">#         data_field = DataField(primary_or_secondary, _key, value, values_str, List, labels, height * 2,</span>
<span class="c1">#                                buttons=buttons, options=prefixed_options)</span>
<span class="c1">#</span>
<span class="c1">#         return data_field</span>
<span class="c1">#</span>
<span class="c1">#     def _create_text_entry_field(self, key, value, x, y, width, height, container, ui_manager) -&gt; DataField:</span>
<span class="c1">#         """</span>
<span class="c1">#         Create a data field containing a text input widget.</span>
<span class="c1">#         """</span>
<span class="c1">#         # split out the elements of the key</span>
<span class="c1">#         primary_or_secondary,  _key = key.split("#")</span>
<span class="c1">#</span>
<span class="c1">#         # create the label</span>
<span class="c1">#         label_width = int(width * self.label_width_mod)</span>
<span class="c1">#         label_rect = pygame.Rect((x, y), (label_width, height))</span>
<span class="c1">#         label = UILabel(label_rect, _key, ui_manager, container=container, parent_element=self)</span>
<span class="c1">#</span>
<span class="c1">#         # create the input</span>
<span class="c1">#         input_width = width - label_width</span>
<span class="c1">#         input_x = x + label_width</span>
<span class="c1">#         input_rect = pygame.Rect((input_x, y), (input_width, height))</span>
<span class="c1">#         input = UITextEntryLine(input_rect, ui_manager, container=container, parent_element=self, object_id=_key)</span>
<span class="c1">#         input.set_text(f"{value}")</span>
<span class="c1">#</span>
<span class="c1">#         # create the data field</span>
<span class="c1">#         data_field = DataField(primary_or_secondary, _key, value, str(value), str, [label], height,</span>
<span class="c1">#                                input_element=input)</span>
<span class="c1">#</span>
<span class="c1">#         return data_field</span>
<span class="c1">#</span>
<span class="c1">#     def _create_row_of_buttons(self, button_names: List[str], x: int, y: int, width: int, height: int) -&gt; Dict[</span>
<span class="c1">#         str, UIButton]:</span>
<span class="c1">#         """</span>
<span class="c1">#         Create a series of button UI widgets on the same x pos.</span>
<span class="c1">#         """</span>
<span class="c1">#         offset_x = 0</span>
<span class="c1">#         container = self.get_container()</span>
<span class="c1">#         buttons = {}</span>
<span class="c1">#</span>
<span class="c1">#         for button_name in button_names:</span>
<span class="c1">#             # split the prefix from the name</span>
<span class="c1">#             try:</span>
<span class="c1">#                 prefix, key, name = button_name.lower().split("#")</span>
<span class="c1">#             except ValueError:</span>
<span class="c1">#                 # if no prefix</span>
<span class="c1">#                 name = button_name.lower()</span>
<span class="c1">#                 key = button_name</span>
<span class="c1">#</span>
<span class="c1">#             # ensure the object ID has no spaces</span>
<span class="c1">#             object_id = button_name.replace(" ", "_")</span>
<span class="c1">#</span>
<span class="c1">#             # create the button</span>
<span class="c1">#             button_rect = pygame.Rect((x + offset_x, y), (width, height))</span>
<span class="c1">#             button = UIButton(button_rect, name, self.ui_manager, container=container,</span>
<span class="c1">#                               parent_element=self, object_id=object_id)</span>
<span class="c1">#             offset_x += width</span>
<span class="c1">#             buttons[object_id] = button</span>
<span class="c1">#</span>
<span class="c1">#         return buttons</span>
<span class="c1">#</span>
<span class="c1">#     ############### LOAD ###################</span>
<span class="c1">#</span>
<span class="c1">#     def _load_field_options(self):</span>
<span class="c1">#         """</span>
<span class="c1">#         Maps the various data keys to their related (options, dataclass). The dataclass is only provided if the key</span>
<span class="c1">#         relates to sub-details that need adding. E.g. effects: (EffectType.__dict__.keys(), EffectData). Loads</span>
<span class="c1">#         details into self.field_options</span>
<span class="c1">#         """</span>
<span class="c1">#         get_members = utility.get_class_members</span>
<span class="c1">#</span>
<span class="c1">#         affliction_options = [key for key in self.all_data["afflictions"].keys()]</span>
<span class="c1">#         aspect_options = [key for key in self.all_data["aspects"].keys()]</span>
<span class="c1">#         effect_options = get_members(EffectType)</span>
<span class="c1">#         primary_stat_options = get_members(PrimaryStat)</span>
<span class="c1">#         secondary_stat_options = get_members(SecondaryStat)</span>
<span class="c1">#         resource_options = get_members(Resource)</span>
<span class="c1">#         bool_options = ["True", "False"]</span>
<span class="c1">#         skill_options = [key for key in self.all_data["skills"].keys()]</span>
<span class="c1">#</span>
<span class="c1">#         field_options = {</span>
<span class="c1">#             "effects": (effect_options, EffectData()),</span>
<span class="c1">#             "affliction_name": (affliction_options, None),</span>
<span class="c1">#             "aspect_name": (aspect_options, None),</span>
<span class="c1">#             "damage_type": (get_members(DamageType), None),</span>
<span class="c1">#             "effect_type": (effect_options, None),</span>
<span class="c1">#             "stat_to_affect": (primary_stat_options + secondary_stat_options, None),</span>
<span class="c1">#             "stat_to_target": (primary_stat_options, None),</span>
<span class="c1">#             "activate_target_tags": (get_members(TargetTag), None),</span>
<span class="c1">#             "mod_stat": (primary_stat_options + secondary_stat_options, None),</span>
<span class="c1">#             "blocks_movement": (bool_options, None),</span>
<span class="c1">#             "blocks_sight": (bool_options, None),</span>
<span class="c1">#             "category": (get_members(AfflictionCategory), None),</span>
<span class="c1">#             "cause": (affliction_options + effect_options + skill_options, None),  # interaction trigger</span>
<span class="c1">#             "primary_stat_type": (primary_stat_options, None),</span>
<span class="c1">#             "secondary_stat_type": (secondary_stat_options, None),</span>
<span class="c1">#             "action": (affliction_options + effect_options + skill_options, None),  # gods attitudes on things</span>
<span class="c1">#             "skill_key": (skill_options, None),</span>
<span class="c1">#             "known_skills": (skill_options, None),</span>
<span class="c1">#             "expiry_type": (get_members(ProjectileExpiry), None),</span>
<span class="c1">#             "resource_type": (resource_options, None),</span>
<span class="c1">#             "shape": (get_members(Shape), None),</span>
<span class="c1">#             "target_directions": (get_members(Direction), None),</span>
<span class="c1">#             "terrain_collision": (get_members(TerrainCollision), None),</span>
<span class="c1">#             "travel_method": (get_members(TravelMethod), None),</span>
<span class="c1">#             "attitudes": (affliction_options + effect_options + skill_options, AttitudeData()),</span>
<span class="c1">#             "interventions": (skill_options, InterventionData()),</span>
<span class="c1">#             "skills": ("", SkillData()),</span>
<span class="c1">#             "afflictions": ("", AfflictionData()),</span>
<span class="c1">#             "aspects": ("", TerrainData()),</span>
<span class="c1">#             "base_stats_primary": ("", BasePrimaryStatData()),</span>
<span class="c1">#             "base_stats_secondary": ("", BaseSecondaryStatData()),</span>
<span class="c1">#             "homelands": ("", TraitData()),</span>
<span class="c1">#             "peoples": ("", TraitData()),</span>
<span class="c1">#             "savvys": ("", TraitData()),</span>
<span class="c1">#             "gods": ("", GodData())</span>
<span class="c1">#         }</span>
<span class="c1">#</span>
<span class="c1">#         self.field_options = field_options</span>
<span class="c1">#</span>
<span class="c1">#     def _load_details(self, primary_or_secondary: str, data_instance: str, secondary_keys: Tuple[str, str] = None):</span>
<span class="c1">#         """</span>
<span class="c1">#         Load details of the specified instance into the primary or secondary section</span>
<span class="c1">#         """</span>
<span class="c1">#         if secondary_keys:</span>
<span class="c1">#             secondary_key, instance_key = secondary_keys</span>
<span class="c1">#         else:</span>
<span class="c1">#             secondary_key = instance_key = ""</span>
<span class="c1">#</span>
<span class="c1">#         # get initial pos info</span>
<span class="c1">#         if primary_or_secondary == "primary":</span>
<span class="c1">#             start_x = self.primary_x</span>
<span class="c1">#             start_y = self.primary_y</span>
<span class="c1">#             row_width = self.primary_width</span>
<span class="c1">#             self.primary_data_fields = {}</span>
<span class="c1">#         else:</span>
<span class="c1">#             start_x = self.secondary_x</span>
<span class="c1">#             start_y = self.secondary_y</span>
<span class="c1">#             row_width = self.secondary_width</span>
<span class="c1">#             self.secondary_data_fields = {}</span>
<span class="c1">#</span>
<span class="c1">#         # get any info we can get ahead of time</span>
<span class="c1">#         container = self.get_container()</span>
<span class="c1">#         manager = self.ui_manager</span>
<span class="c1">#         row_height = self.row_height</span>
<span class="c1">#         current_y = start_y</span>
<span class="c1">#         data_fields = {}</span>
<span class="c1">#         all_data = self.all_data</span>
<span class="c1">#         category = self.current_data_category</span>
<span class="c1">#         instance = data_instance</span>
<span class="c1">#         field_options = self.field_options</span>
<span class="c1">#</span>
<span class="c1">#         # point to the required dataclasses</span>
<span class="c1">#         if primary_or_secondary == "secondary" and secondary_key != "" and instance_key != "":</span>
<span class="c1">#             instance_dict = getattr(all_data[category][instance], secondary_key)</span>
<span class="c1">#</span>
<span class="c1">#             # see if we have existing values</span>
<span class="c1">#             try:</span>
<span class="c1">#                 inner_dataclass = instance_dict[instance_key.lower()]</span>
<span class="c1">#</span>
<span class="c1">#             except KeyError:</span>
<span class="c1">#                 # get the data class from the possible field options</span>
<span class="c1">#                 _key, inner_dataclass = field_options[secondary_key]</span>
<span class="c1">#</span>
<span class="c1">#                 # assign the key</span>
<span class="c1">#                 instance_dict[instance_key] = inner_dataclass</span>
<span class="c1">#</span>
<span class="c1">#         elif primary_or_secondary == "secondary" and not secondary_key:</span>
<span class="c1">#             instance_dict = getattr(all_data[category][instance], self.current_primary_field)</span>
<span class="c1">#             inner_dataclass = instance_dict[self.key_being_edited]</span>
<span class="c1">#</span>
<span class="c1">#         else:</span>
<span class="c1">#             # handle a new data instance by getting the relevant dataclass</span>
<span class="c1">#             if instance == "new":</span>
<span class="c1">#                 outer_dict = all_data[category]</span>
<span class="c1">#                 if category in field_options:</span>
<span class="c1">#                     options, inner_dataclass = field_options[category]</span>
<span class="c1">#</span>
<span class="c1">#                     # assign the key</span>
<span class="c1">#                     outer_dict["new"] = inner_dataclass</span>
<span class="c1">#</span>
<span class="c1">#             else:</span>
<span class="c1">#                 inner_dataclass = all_data[category][instance]</span>
<span class="c1">#</span>
<span class="c1">#         # convert dataclass to dict to loop values</span>
<span class="c1">#         data_dict = dataclasses.asdict(inner_dataclass)</span>
<span class="c1">#</span>
<span class="c1">#         # create data fields</span>
<span class="c1">#         for key, value in data_dict.items():</span>
<span class="c1">#             try:</span>
<span class="c1">#                 if key in field_options:</span>
<span class="c1">#                     options, secondary_fields = field_options[key]</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     options = []</span>
<span class="c1">#                     secondary_fields = ""</span>
<span class="c1">#</span>
<span class="c1">#                 # modify key to include the prefix</span>
<span class="c1">#                 prefix_key = primary_or_secondary + "#" + key</span>
<span class="c1">#</span>
<span class="c1">#                 # have we identified the secondary fields?</span>
<span class="c1">#                 if secondary_fields != "":</span>
<span class="c1">#                     data_field = self._create_edit_detail_field(prefix_key, value, options, start_x, current_y,</span>
<span class="c1">#                                                                 row_width, row_height, container, manager)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     if options:</span>
<span class="c1">#                         # if key name is plural</span>
<span class="c1">#                         if key[len(key) - 1:] == "s":</span>
<span class="c1">#                             data_field = self._create_multiple_from_options_field(prefix_key, value, options,</span>
<span class="c1">#                                                                                   start_x,</span>
<span class="c1">#                                                                                   current_y, row_width, row_height,</span>
<span class="c1">#                                                                                   container, manager)</span>
<span class="c1">#                         # singular name, only pick one</span>
<span class="c1">#                         else:</span>
<span class="c1">#                             data_field = self._create_one_from_options_field(prefix_key, value, options, start_x,</span>
<span class="c1">#                                                                              current_y, row_width, row_height,</span>
<span class="c1">#                                                                              container, manager)</span>
<span class="c1">#                     # no options so it must be a text field</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         data_field = self._create_text_entry_field(prefix_key, value, start_x, current_y, row_width,</span>
<span class="c1">#                                                                    row_height, container, manager)</span>
<span class="c1">#</span>
<span class="c1">#                 # increment Y</span>
<span class="c1">#                 current_y += data_field.height + 1</span>
<span class="c1">#</span>
<span class="c1">#                 # save the data field</span>
<span class="c1">#                 data_fields[key] = data_field</span>
<span class="c1">#             except ValueError as e:</span>
<span class="c1">#                 logging.warning(f"Error ({e}) trying to create_entity data field for {key}:{value}.")</span>
<span class="c1">#</span>
<span class="c1">#         # update the main record</span>
<span class="c1">#         if primary_or_secondary == "primary":</span>
<span class="c1">#             self.primary_data_fields = {}</span>
<span class="c1">#             self.primary_data_fields = data_fields</span>
<span class="c1">#         elif primary_or_secondary == "secondary":</span>
<span class="c1">#             self.secondary_data_fields = {}</span>
<span class="c1">#             self.secondary_data_fields = data_fields</span>
<span class="c1">#         else:</span>
<span class="c1">#             self.primary_data_fields = {}</span>
<span class="c1">#             self.primary_data_fields = data_fields</span>
<span class="c1">#</span>
<span class="c1">#         # take note of the highest used y, for the scroll bar</span>
<span class="c1">#         self.max_y = max(current_y, self.max_y)</span>
<span class="c1">#</span>
<span class="c1">#     def _load_library_data(self):</span>
<span class="c1">#         """</span>
<span class="c1">#         Load all of the data options into self.all_data</span>
<span class="c1">#         """</span>
<span class="c1">#         self.all_data = {</span>
<span class="c1">#             "base_stats_primary": library.get_primary_stats_data(),</span>
<span class="c1">#             "base_stats_secondary": library.get_secondary_stats_data(),</span>
<span class="c1">#             "homelands": library.get_homelands_data(),</span>
<span class="c1">#             "peoples": library.get_peoples_data(),</span>
<span class="c1">#             "savvys": library.get_savvys_data(),</span>
<span class="c1">#             "afflictions": library.get_afflictions_data(),</span>
<span class="c1">#             "skills": library.get_skills_data(),</span>
<span class="c1">#             "aspects": library.get_aspects_data(),</span>
<span class="c1">#             "gods": library.get_gods_data()</span>
<span class="c1">#         }</span>
<span class="c1">#</span>
<span class="c1">#     ############## CLEAR #####################</span>
<span class="c1">#</span>
<span class="c1">#     def kill(self):</span>
<span class="c1">#         """</span>
<span class="c1">#         Clear all held data.</span>
<span class="c1">#         """</span>
<span class="c1">#</span>
<span class="c1">#         if self.category_selector:</span>
<span class="c1">#             self.category_selector.kill()</span>
<span class="c1">#             self.category_selector = None</span>
<span class="c1">#         if self.instance_selector:</span>
<span class="c1">#             self.instance_selector.kill()</span>
<span class="c1">#             self.instance_selector = None</span>
<span class="c1">#         if self.primary_data_fields:</span>
<span class="c1">#             self._kill_details_fields("primary")</span>
<span class="c1">#             self.primary_data_fields = {}</span>
<span class="c1">#         if self.secondary_data_fields:</span>
<span class="c1">#             self._kill_details_fields("secondary")</span>
<span class="c1">#             self.secondary_data_fields = {}</span>
<span class="c1">#</span>
<span class="c1">#         super().kill()</span>
<span class="c1">#</span>
<span class="c1">#     def _kill_details_fields(self, primary_or_secondary: str):</span>
<span class="c1">#         """</span>
<span class="c1">#         Clear currently held details in the given dict of data fields.</span>
<span class="c1">#         """</span>
<span class="c1">#         if primary_or_secondary == "primary":</span>
<span class="c1">#             self.current_primary_field = ""</span>
<span class="c1">#             data_fields = self.primary_data_fields</span>
<span class="c1">#         elif primary_or_secondary == "secondary":</span>
<span class="c1">#             self.current_secondary_field = ""</span>
<span class="c1">#             data_fields = self.secondary_data_fields</span>
<span class="c1">#         else:</span>
<span class="c1">#             data_fields = self.primary_data_fields</span>
<span class="c1">#</span>
<span class="c1">#         # clear the data fields</span>
<span class="c1">#         for data_field in data_fields.values():</span>
<span class="c1">#             data_field.kill()</span>
<span class="c1">#</span>
<span class="c1">#         # clear the dict</span>
<span class="c1">#         if primary_or_secondary == "primary":</span>
<span class="c1">#             self.primary_data_fields = {}</span>
<span class="c1">#         elif primary_or_secondary == "secondary":</span>
<span class="c1">#             self.secondary_data_fields = {}</span>
<span class="c1">#         else:</span>
<span class="c1">#             self.primary_data_fields = {}</span>
<span class="c1">#</span>
<span class="c1">#     ############ SAVE ##################</span>
<span class="c1">#</span>
<span class="c1">#     def _save_updated_field(self, primary_or_secondary, data_field: DataField, updated_value: Any):</span>
<span class="c1">#         """</span>
<span class="c1">#         Save the updated value to the main dict held in self.all_data</span>
<span class="c1">#         """</span>
<span class="c1">#         # if primary then grab from 4th layer; all_data:category:instance:data_field</span>
<span class="c1">#         if primary_or_secondary == "primary":</span>
<span class="c1">#             # if we have a new data set</span>
<span class="c1">#             if self.current_data_instance == "new":</span>
<span class="c1">#                 # if we have changed the name</span>
<span class="c1">#                 if data_field.key == "name":</span>
<span class="c1">#                     # move the "new" key to a key using the name</span>
<span class="c1">#                     name = data_field.input_element.text.lower()  # It will be a text field, as the name always is</span>
<span class="c1">#                     self.all_data[self.current_data_category][name] = self.all_data[self.current_data_category].pop(</span>
<span class="c1">#                         self.current_data_instance)</span>
<span class="c1">#</span>
<span class="c1">#                     # update current instance</span>
<span class="c1">#                     self.current_data_instance = name</span>
<span class="c1">#</span>
<span class="c1">#             # set the primary value</span>
<span class="c1">#             setattr(self.all_data[self.current_data_category][self.current_data_instance], data_field.key,</span>
<span class="c1">#                     updated_value)</span>
<span class="c1">#</span>
<span class="c1">#         else:</span>
<span class="c1">#             # get the selected primary field</span>
<span class="c1">#             primary = getattr(self.all_data[self.current_data_category][self.current_data_instance],</span>
<span class="c1">#                               self.primary_data_fields[self.current_primary_field].key)</span>
<span class="c1">#             setattr(primary[self.key_being_edited], data_field.key, updated_value)</span>
<span class="c1">#</span>
<span class="c1">#         # save back to json</span>
<span class="c1">#         with open(f"data/game/{self.current_data_category}.json", "w") as file:</span>
<span class="c1">#             json.dump(self.all_data[self.current_data_category], file, sort_keys=True, indent=4,</span>
<span class="c1">#                       cls=ExtendedJsonEncoder)</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># class DataField:</span>
<span class="c1">#     """</span>
<span class="c1">#     Holds a set of related data and ui_manager elements</span>
<span class="c1">#     """</span>
<span class="c1">#     def __init__(self, primary_or_secondary: str, key: str, value: Any, value_as_str: str, value_type, labels: List,</span>
<span class="c1">#         height: int, input_element=None, buttons: Dict[str, UIButton] = None, options: List = None):</span>
<span class="c1">#         self.primary_or_secondary = primary_or_secondary</span>
<span class="c1">#         self.key = key</span>
<span class="c1">#         self.value = value</span>
<span class="c1">#         self.value_as_str = value_as_str</span>
<span class="c1">#         self.value_type = value_type</span>
<span class="c1">#         self.options = options</span>
<span class="c1">#         self.height = height</span>
<span class="c1">#</span>
<span class="c1">#         # ui_manager elements</span>
<span class="c1">#         self.input_element = input_element</span>
<span class="c1">#         self.labels = labels</span>
<span class="c1">#         self.buttons = buttons</span>
<span class="c1">#</span>
<span class="c1">#     def kill(self):</span>
<span class="c1">#         """</span>
<span class="c1">#         Kill all held ui_manager elements</span>
<span class="c1">#         """</span>
<span class="c1">#         if self.input_element:</span>
<span class="c1">#             self.input_element.kill()</span>
<span class="c1">#             self.input_element = None</span>
<span class="c1">#</span>
<span class="c1">#         if self.labels:</span>
<span class="c1">#             for label in self.labels:</span>
<span class="c1">#                 label.kill()</span>
<span class="c1">#             self.labels = None</span>
<span class="c1">#</span>
<span class="c1">#         if self.buttons:</span>
<span class="c1">#             for key, button in self.buttons.items():</span>
<span class="c1">#                 button.kill()</span>
<span class="c1">#             self.buttons = None</span>
</pre></div>

          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2019-2020, Josh Snaith.
              
          </div>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 3.3.1.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../../../../../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>